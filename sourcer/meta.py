# Generated by ../generate_metasyntax.py
from collections import namedtuple as _nt
from re import compile as compile_re



class Node:
    _fields = ()

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            if getattr(self, field) != getattr(other, field):
                return False
        return True

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        return self.__class__(**kw)


class Rule:
    def __init__(self, name, parse):
        self.name = name
        self.parse = parse

    def __repr__(self):
        return f'Rule(name={self.name!r}, parse={self.parse.__name__})'



import ast
import textwrap



class ParseError(Exception):
    def __init__(self, expr_code, pos):
        self.expr_code = expr_code
        self.pos = pos


class Infix(Node):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(Node):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(Node):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0):
    return _run(text, pos, _cont_start)


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _text, _pos):
        return self.func(_text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _text, _pos):
        return self._parse_function(_text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


def _run(text, pos, start):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return result[1]
    else:
        raise ParseError(result[1], result[2])


def visit(node):
    if isinstance(node, list):
        yield from node

    elif isinstance(node, Node):
        yield node

        if hasattr(node, '_fields'):
            for field in node._fields:
                yield from visit(getattr(node, field))


def transform(node, *callbacks):
    if not callbacks:
        return node

    if len(callbacks) == 1:
        callback = callbacks[0]
    else:
        def callback(node):
            for f in callbacks:
                node = f(node)
            return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, Node):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if was is not now:
            updates[field] = now

    if updates:
        node = node._replace(**updates)

    return callback(node)




matcher1 = compile_re('[ \\t]+').match
matcher2 = compile_re('#[^\\r\\n]*').match
matcher3 = compile_re('[\\r\\n][\\s]*').match
matcher4 = compile_re('[_a-zA-Z][_a-zA-Z0-9]*').match
matcher5 = compile_re('(?s)("""([^\\\\]|\\\\.)*?""")').match
matcher6 = compile_re("(?s)('''([^\\\\]|\\\\.)*?''')").match
matcher7 = compile_re('("([^"\\\\]|\\\\.)*")').match
matcher8 = compile_re("('([^'\\\\]|\\\\.)*')").match
matcher9 = compile_re('\\@\\/([^\\/\\\\]|\\\\.)*\\/').match
matcher10 = compile_re('(?s)```.*?```').match
matcher11 = compile_re('`.*?`').match


def _cont_Space(_text, _pos):
     match1 = matcher1(_text, _pos)
     if match1:
          _pos = match1.end()
          _status = True
          _result = match1.group(0)
     else:
          _status = False
          _result = 2
     (yield (_status, _result, _pos,))


def _parse_Space(text, pos=0):
     return _run(text, pos, _cont_Space)


Space = Rule('Space', _parse_Space)

def _cont_Comment(_text, _pos):
     match2 = matcher2(_text, _pos)
     if match2:
          _pos = match2.end()
          _status = True
          _result = match2.group(0)
     else:
          _status = False
          _result = 4
     (yield (_status, _result, _pos,))


def _parse_Comment(text, pos=0):
     return _run(text, pos, _cont_Comment)


Comment = Rule('Comment', _parse_Comment)

def _cont_Newline(_text, _pos):
     match3 = matcher3(_text, _pos)
     if match3:
          _pos = (yield (3, _cont__ignored, match3.end(),))[2]
          _status = True
          _result = match3.group(0)
     else:
          _status = False
          _result = 6
     (yield (_status, _result, _pos,))


def _parse_Newline(text, pos=0):
     return _run(text, pos, _cont_Newline)


Newline = Rule('Newline', _parse_Newline)

def _cont_Sep(_text, _pos):
     staging1 = []
     while True:
          checkpoint1 = _pos
          backtrack1 = farthest_pos1 = _pos
          farthest_expr1 = 9
          while True:
               (_status, _result, _pos,) = (yield (3, _cont_Newline, _pos,))
               if _status:
                    break
               if (farthest_pos1 < _pos):
                    farthest_pos1 = _pos
                    farthest_expr1 = 10
               _pos = backtrack1
               value1 = ';'
               end1 = (_pos + 1)
               if (_text[_pos : end1] == value1):
                    _pos = (yield (3, _cont__ignored, end1,))[2]
                    _status = True
                    _result = value1
               else:
                    _status = False
                    _result = 11
               if _status:
                    break
               _pos = farthest_pos1
               _result = 9
               break
          if _status:
               staging1.append(_result)
               continue
          else:
               _pos = checkpoint1
               break
     if staging1:
          _result = staging1
          _status = True
     (yield (_status, _result, _pos,))


def _parse_Sep(text, pos=0):
     return _run(text, pos, _cont_Sep)


Sep = Rule('Sep', _parse_Sep)

def _cont_Name(_text, _pos):
     match4 = matcher4(_text, _pos)
     if match4:
          _pos = (yield (3, _cont__ignored, match4.end(),))[2]
          _status = True
          _result = match4.group(0)
     else:
          _status = False
          _result = 13
     (yield (_status, _result, _pos,))


def _parse_Name(text, pos=0):
     return _run(text, pos, _cont_Name)


Name = Rule('Name', _parse_Name)

def _parse_function_17(_text, _pos):
     value2 = ','
     end2 = (_pos + 1)
     if (_text[_pos : end2] == value2):
          _pos = (yield (3, _cont__ignored, end2,))[2]
          _status = True
          _result = value2
     else:
          _status = False
          _result = 17
     (yield (_status, _result, _pos,))


def _cont_Comma(_text, _pos):
     arg1 = _wrap_string_literal(',', _parse_function_17)
     func1 = _ParseFunction(_cont_wrap, (arg1,), ())
     (_status, _result, _pos,) = (yield (3, func1, _pos,))
     (yield (_status, _result, _pos,))


def _parse_Comma(text, pos=0):
     return _run(text, pos, _cont_Comma)


Comma = Rule('Comma', _parse_Comma)

def _cont_wrap(_text, _pos, x):
     while True:
          while True:
               while True:
                    checkpoint2 = _pos
                    (_status, _result, _pos,) = (yield (3, _cont_Newline, _pos,))
                    if _status:
                         continue
                    else:
                         _pos = checkpoint2
                    break
               _status = True
               _result = None
               if (not _status):
                    break
               (_status, _result, _pos,) = (yield (3, x, _pos,))
               break
          if (not _status):
               break
          staging2 = _result
          while True:
               checkpoint3 = _pos
               (_status, _result, _pos,) = (yield (3, _cont_Newline, _pos,))
               if _status:
                    continue
               else:
                    _pos = checkpoint3
               break
          _status = True
          _result = None
          if _status:
               _result = staging2
          break
     (yield (_status, _result, _pos,))


def _parse_wrap(text, pos=0):
     return _run(text, pos, _cont_wrap)


wrap = Rule('wrap', _parse_wrap)

def _cont_kw(_text, _pos, word):
     (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
     if _status:
          arg2 = _result
          _result = lambda x: x == word
          _status = True
          if _status:
               if _result(arg2):
                    _result = arg2
               else:
                    _status = False
                    _result = 27
     (yield (_status, _result, _pos,))


def _parse_kw(text, pos=0):
     return _run(text, pos, _cont_kw)


kw = Rule('kw', _parse_kw)

def _parse_function_35(_text, _pos):
     value3 = '('
     end3 = (_pos + 1)
     if (_text[_pos : end3] == value3):
          _pos = (yield (3, _cont__ignored, end3,))[2]
          _status = True
          _result = value3
     else:
          _status = False
          _result = 35
     (yield (_status, _result, _pos,))


def _cont_Params(_text, _pos):
     while True:
          while True:
               arg3 = _wrap_string_literal('(', _parse_function_35)
               func2 = _ParseFunction(_cont_wrap, (arg3,), ())
               (_status, _result, _pos,) = (yield (3, func2, _pos,))
               if (not _status):
                    break
               staging3 = []
               checkpoint4 = _pos
               while True:
                    func3 = _ParseFunction(_cont_wrap, (_cont_Name,), ())
                    (_status, _result, _pos,) = (yield (3, func3, _pos,))
                    if (not _status):
                         break
                    staging3.append(_result)
                    checkpoint4 = _pos
                    (_status, _result, _pos,) = (yield (3, _cont_Comma, _pos,))
                    if (not _status):
                         break
                    checkpoint4 = _pos
               _result = staging3
               _status = True
               _pos = checkpoint4
               break
          if (not _status):
               break
          staging4 = _result
          value4 = ')'
          end4 = (_pos + 1)
          if (_text[_pos : end4] == value4):
               _pos = (yield (3, _cont__ignored, end4,))[2]
               _status = True
               _result = value4
          else:
               _status = False
               _result = 41
          if _status:
               _result = staging4
          break
     (yield (_status, _result, _pos,))


def _parse_Params(text, pos=0):
     return _run(text, pos, _cont_Params)


Params = Rule('Params', _parse_Params)

class StringLiteral(Node):
     _fields = ('value',)
     def __init__(self, value):
          self.value = value

     def __repr__(self):
          return f'StringLiteral(value={self.value!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_StringLiteral)



def _cont_StringLiteral(_text, _pos):
     while True:
          backtrack2 = farthest_pos2 = _pos
          farthest_expr2 = 45
          while True:
               match5 = matcher5(_text, _pos)
               if match5:
                    _pos = (yield (3, _cont__ignored, match5.end(),))[2]
                    _status = True
                    _result = match5.group(0)
               else:
                    _status = False
                    _result = 46
               if _status:
                    break
               match6 = matcher6(_text, _pos)
               if match6:
                    _pos = (yield (3, _cont__ignored, match6.end(),))[2]
                    _status = True
                    _result = match6.group(0)
               else:
                    _status = False
                    _result = 47
               if _status:
                    break
               match7 = matcher7(_text, _pos)
               if match7:
                    _pos = (yield (3, _cont__ignored, match7.end(),))[2]
                    _status = True
                    _result = match7.group(0)
               else:
                    _status = False
                    _result = 48
               if _status:
                    break
               match8 = matcher8(_text, _pos)
               if match8:
                    _pos = (yield (3, _cont__ignored, match8.end(),))[2]
                    _status = True
                    _result = match8.group(0)
               else:
                    _status = False
                    _result = 49
               if _status:
                    break
               _pos = farthest_pos2
               _result = 45
               break
          if _status:
               arg4 = _result
               _result = ast.literal_eval
               _status = True
               if _status:
                    _result = _result(arg4)
          if (not _status):
               break
          value = _result
          _result = StringLiteral(value)
          break
     (yield (_status, _result, _pos,))


class RegexLiteral(Node):
     _fields = ('value',)
     def __init__(self, value):
          self.value = value

     def __repr__(self):
          return f'RegexLiteral(value={self.value!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_RegexLiteral)



def _cont_RegexLiteral(_text, _pos):
     while True:
          match9 = matcher9(_text, _pos)
          if match9:
               _pos = (yield (3, _cont__ignored, match9.end(),))[2]
               _status = True
               _result = match9.group(0)
          else:
               _status = False
               _result = 54
          if _status:
               arg5 = _result
               _result = lambda x: x[2:-1]
               _status = True
               if _status:
                    _result = _result(arg5)
          if (not _status):
               break
          value = _result
          _result = RegexLiteral(value)
          break
     (yield (_status, _result, _pos,))


class PythonSection(Node):
     _fields = ('value',)
     def __init__(self, value):
          self.value = value

     def __repr__(self):
          return f'PythonSection(value={self.value!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_PythonSection)



def _cont_PythonSection(_text, _pos):
     while True:
          match10 = matcher10(_text, _pos)
          if match10:
               _pos = (yield (3, _cont__ignored, match10.end(),))[2]
               _status = True
               _result = match10.group(0)
          else:
               _status = False
               _result = 59
          if _status:
               arg6 = _result
               _result = lambda x: textwrap.dedent(x[3:-3])
               _status = True
               if _status:
                    _result = _result(arg6)
          if (not _status):
               break
          value = _result
          _result = PythonSection(value)
          break
     (yield (_status, _result, _pos,))


class PythonExpression(Node):
     _fields = ('value',)
     def __init__(self, value):
          self.value = value

     def __repr__(self):
          return f'PythonExpression(value={self.value!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_PythonExpression)



def _cont_PythonExpression(_text, _pos):
     while True:
          match11 = matcher11(_text, _pos)
          if match11:
               _pos = (yield (3, _cont__ignored, match11.end(),))[2]
               _status = True
               _result = match11.group(0)
          else:
               _status = False
               _result = 64
          if _status:
               arg7 = _result
               _result = lambda x: x[1:-1]
               _status = True
               if _status:
                    _result = _result(arg7)
          if (not _status):
               break
          value = _result
          _result = PythonExpression(value)
          break
     (yield (_status, _result, _pos,))


class RuleDef(Node):
     _fields = ('is_ignored', 'name', 'params', 'expr',)
     def __init__(self, is_ignored, name, params, expr):
          self.is_ignored = is_ignored
          self.name = name
          self.params = params
          self.expr = expr

     def __repr__(self):
          return f'RuleDef(is_ignored={self.is_ignored!r}, name={self.name!r}, params={self.params!r}, expr={self.expr!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_RuleDef)



def _parse_function_73(_text, _pos):
     value5 = 'ignored'
     end5 = (_pos + 7)
     if (_text[_pos : end5] == value5):
          _pos = (yield (3, _cont__ignored, end5,))[2]
          _status = True
          _result = value5
     else:
          _status = False
          _result = 73
     (yield (_status, _result, _pos,))


def _parse_function_76(_text, _pos):
     value6 = 'ignore'
     end6 = (_pos + 6)
     if (_text[_pos : end6] == value6):
          _pos = (yield (3, _cont__ignored, end6,))[2]
          _status = True
          _result = value6
     else:
          _status = False
          _result = 76
     (yield (_status, _result, _pos,))


def _parse_function_86(_text, _pos):
     backtrack3 = farthest_pos3 = _pos
     farthest_expr3 = 86
     while True:
          value7 = '=>'
          end7 = (_pos + 2)
          if (_text[_pos : end7] == value7):
               _pos = (yield (3, _cont__ignored, end7,))[2]
               _status = True
               _result = value7
          else:
               _status = False
               _result = 87
          if _status:
               break
          value8 = '='
          end8 = (_pos + 1)
          if (_text[_pos : end8] == value8):
               _pos = (yield (3, _cont__ignored, end8,))[2]
               _status = True
               _result = value8
          else:
               _status = False
               _result = 88
          if _status:
               break
          value9 = ':'
          end9 = (_pos + 1)
          if (_text[_pos : end9] == value9):
               _pos = (yield (3, _cont__ignored, end9,))[2]
               _status = True
               _result = value9
          else:
               _status = False
               _result = 89
          if _status:
               break
          _pos = farthest_pos3
          _result = 86
          break
     (yield (_status, _result, _pos,))


def _cont_RuleDef(_text, _pos):
     while True:
          backtrack4 = _pos
          backtrack5 = farthest_pos4 = _pos
          farthest_expr4 = 70
          while True:
               arg8 = _wrap_string_literal('ignored', _parse_function_73)
               func4 = _ParseFunction(_cont_kw, (arg8,), ())
               (_status, _result, _pos,) = (yield (3, func4, _pos,))
               if _status:
                    break
               if (farthest_pos4 < _pos):
                    farthest_pos4 = _pos
                    farthest_expr4 = 71
               _pos = backtrack5
               arg9 = _wrap_string_literal('ignore', _parse_function_76)
               func5 = _ParseFunction(_cont_kw, (arg9,), ())
               (_status, _result, _pos,) = (yield (3, func5, _pos,))
               if _status:
                    break
               if (farthest_pos4 < _pos):
                    farthest_pos4 = _pos
                    farthest_expr4 = 74
               _pos = farthest_pos4
               _result = 70
               break
          if (not _status):
               _status = True
               _pos = backtrack4
               _result = None
          if _status:
               arg10 = _result
               _result = bool
               _status = True
               if _status:
                    _result = _result(arg10)
          if (not _status):
               break
          is_ignored = _result
          (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
          if (not _status):
               break
          name = _result
          while True:
               backtrack6 = _pos
               (_status, _result, _pos,) = (yield (3, _cont_Params, _pos,))
               if (not _status):
                    _status = True
                    _pos = backtrack6
                    _result = None
               if (not _status):
                    break
               staging5 = _result
               func6 = _ParseFunction(_cont_wrap, (_parse_function_86,), ())
               (_status, _result, _pos,) = (yield (3, func6, _pos,))
               if _status:
                    _result = staging5
               break
          if (not _status):
               break
          params = _result
          (_status, _result, _pos,) = (yield (3, _cont_Expr, _pos,))
          if (not _status):
               break
          expr = _result
          _result = RuleDef(is_ignored, name, params, expr)
          break
     (yield (_status, _result, _pos,))


class ClassDef(Node):
     _fields = ('name', 'params', 'fields',)
     def __init__(self, name, params, fields):
          self.name = name
          self.params = params
          self.fields = fields

     def __repr__(self):
          return f'ClassDef(name={self.name!r}, params={self.params!r}, fields={self.fields!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_ClassDef)



def _parse_function_97(_text, _pos):
     value10 = 'class'
     end10 = (_pos + 5)
     if (_text[_pos : end10] == value10):
          _pos = (yield (3, _cont__ignored, end10,))[2]
          _status = True
          _result = value10
     else:
          _status = False
          _result = 97
     (yield (_status, _result, _pos,))


def _parse_function_107(_text, _pos):
     value11 = '{'
     end11 = (_pos + 1)
     if (_text[_pos : end11] == value11):
          _pos = (yield (3, _cont__ignored, end11,))[2]
          _status = True
          _result = value11
     else:
          _status = False
          _result = 107
     (yield (_status, _result, _pos,))


def _cont_ClassDef(_text, _pos):
     while True:
          while True:
               arg11 = _wrap_string_literal('class', _parse_function_97)
               func7 = _ParseFunction(_cont_kw, (arg11,), ())
               (_status, _result, _pos,) = (yield (3, func7, _pos,))
               if (not _status):
                    break
               (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
               break
          if (not _status):
               break
          name = _result
          backtrack7 = _pos
          (_status, _result, _pos,) = (yield (3, _cont_Params, _pos,))
          if (not _status):
               _status = True
               _pos = backtrack7
               _result = None
          if (not _status):
               break
          params = _result
          while True:
               while True:
                    arg12 = _wrap_string_literal('{', _parse_function_107)
                    func8 = _ParseFunction(_cont_wrap, (arg12,), ())
                    (_status, _result, _pos,) = (yield (3, func8, _pos,))
                    if (not _status):
                         break
                    staging6 = []
                    checkpoint5 = _pos
                    while True:
                         (_status, _result, _pos,) = (yield (3, _cont_RuleDef, _pos,))
                         if (not _status):
                              break
                         staging6.append(_result)
                         checkpoint5 = _pos
                         (_status, _result, _pos,) = (yield (3, _cont_Sep, _pos,))
                         if (not _status):
                              break
                         checkpoint5 = _pos
                    _result = staging6
                    _status = True
                    _pos = checkpoint5
                    break
               if (not _status):
                    break
               staging7 = _result
               value12 = '}'
               end12 = (_pos + 1)
               if (_text[_pos : end12] == value12):
                    _pos = (yield (3, _cont__ignored, end12,))[2]
                    _status = True
                    _result = value12
               else:
                    _status = False
                    _result = 111
               if _status:
                    _result = staging7
               break
          if (not _status):
               break
          fields = _result
          _result = ClassDef(name, params, fields)
          break
     (yield (_status, _result, _pos,))


def _cont_Stmt(_text, _pos):
     backtrack8 = farthest_pos5 = _pos
     farthest_expr5 = 113
     while True:
          (_status, _result, _pos,) = (yield (3, _cont_ClassDef, _pos,))
          if _status:
               break
          if (farthest_pos5 < _pos):
               farthest_pos5 = _pos
               farthest_expr5 = 114
          _pos = backtrack8
          (_status, _result, _pos,) = (yield (3, _cont_RuleDef, _pos,))
          if _status:
               break
          if (farthest_pos5 < _pos):
               farthest_pos5 = _pos
               farthest_expr5 = 115
          _pos = backtrack8
          (_status, _result, _pos,) = (yield (3, _cont_PythonSection, _pos,))
          if _status:
               break
          if (farthest_pos5 < _pos):
               farthest_pos5 = _pos
               farthest_expr5 = 116
          _pos = backtrack8
          (_status, _result, _pos,) = (yield (3, _cont_PythonExpression, _pos,))
          if _status:
               break
          if (farthest_pos5 < _pos):
               farthest_pos5 = _pos
               farthest_expr5 = 117
          _pos = farthest_pos5
          _result = 113
          break
     (yield (_status, _result, _pos,))


def _parse_Stmt(text, pos=0):
     return _run(text, pos, _cont_Stmt)


Stmt = Rule('Stmt', _parse_Stmt)

class LetExpression(Node):
     _fields = ('name', 'expr', 'body',)
     def __init__(self, name, expr, body):
          self.name = name
          self.expr = expr
          self.body = body

     def __repr__(self):
          return f'LetExpression(name={self.name!r}, expr={self.expr!r}, body={self.body!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_LetExpression)



def _parse_function_124(_text, _pos):
     value13 = 'let'
     end13 = (_pos + 3)
     if (_text[_pos : end13] == value13):
          _pos = (yield (3, _cont__ignored, end13,))[2]
          _status = True
          _result = value13
     else:
          _status = False
          _result = 124
     (yield (_status, _result, _pos,))


def _parse_function_128(_text, _pos):
     value14 = '='
     end14 = (_pos + 1)
     if (_text[_pos : end14] == value14):
          _pos = (yield (3, _cont__ignored, end14,))[2]
          _status = True
          _result = value14
     else:
          _status = False
          _result = 128
     (yield (_status, _result, _pos,))


def _parse_function_136(_text, _pos):
     value15 = 'in'
     end15 = (_pos + 2)
     if (_text[_pos : end15] == value15):
          _pos = (yield (3, _cont__ignored, end15,))[2]
          _status = True
          _result = value15
     else:
          _status = False
          _result = 136
     (yield (_status, _result, _pos,))


def _parse_function_134(_text, _pos):
     arg13 = _wrap_string_literal('in', _parse_function_136)
     func9 = _ParseFunction(_cont_kw, (arg13,), ())
     (_status, _result, _pos,) = (yield (3, func9, _pos,))
     (yield (_status, _result, _pos,))


def _cont_LetExpression(_text, _pos):
     while True:
          while True:
               while True:
                    arg14 = _wrap_string_literal('let', _parse_function_124)
                    func10 = _ParseFunction(_cont_kw, (arg14,), ())
                    (_status, _result, _pos,) = (yield (3, func10, _pos,))
                    if (not _status):
                         break
                    (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
                    break
               if (not _status):
                    break
               staging8 = _result
               arg15 = _wrap_string_literal('=', _parse_function_128)
               func11 = _ParseFunction(_cont_wrap, (arg15,), ())
               (_status, _result, _pos,) = (yield (3, func11, _pos,))
               if _status:
                    _result = staging8
               break
          if (not _status):
               break
          name = _result
          while True:
               (_status, _result, _pos,) = (yield (3, _cont_Expr, _pos,))
               if (not _status):
                    break
               staging9 = _result
               func12 = _ParseFunction(_cont_wrap, (_parse_function_134,), ())
               (_status, _result, _pos,) = (yield (3, func12, _pos,))
               if _status:
                    _result = staging9
               break
          if (not _status):
               break
          expr = _result
          (_status, _result, _pos,) = (yield (3, _cont_Expr, _pos,))
          if (not _status):
               break
          body = _result
          _result = LetExpression(name, expr, body)
          break
     (yield (_status, _result, _pos,))


class Ref(Node):
     _fields = ('value',)
     def __init__(self, value):
          self.value = value

     def __repr__(self):
          return f'Ref(value={self.value!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_Ref)



def _cont_Ref(_text, _pos):
     while True:
          (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
          if (not _status):
               break
          value = _result
          _result = Ref(value)
          break
     (yield (_status, _result, _pos,))


class ListLiteral(Node):
     _fields = ('elements',)
     def __init__(self, elements):
          self.elements = elements

     def __repr__(self):
          return f'ListLiteral(elements={self.elements!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_ListLiteral)



def _cont_ListLiteral(_text, _pos):
     while True:
          while True:
               while True:
                    value16 = '['
                    end16 = (_pos + 1)
                    if (_text[_pos : end16] == value16):
                         _pos = (yield (3, _cont__ignored, end16,))[2]
                         _status = True
                         _result = value16
                    else:
                         _status = False
                         _result = 146
                    if (not _status):
                         break
                    staging10 = []
                    checkpoint6 = _pos
                    while True:
                         func13 = _ParseFunction(_cont_wrap, (_cont_Expr,), ())
                         (_status, _result, _pos,) = (yield (3, func13, _pos,))
                         if (not _status):
                              break
                         staging10.append(_result)
                         checkpoint6 = _pos
                         (_status, _result, _pos,) = (yield (3, _cont_Comma, _pos,))
                         if (not _status):
                              break
                         checkpoint6 = _pos
                    _result = staging10
                    _status = True
                    _pos = checkpoint6
                    break
               if (not _status):
                    break
               staging11 = _result
               value17 = ']'
               end17 = (_pos + 1)
               if (_text[_pos : end17] == value17):
                    _pos = (yield (3, _cont__ignored, end17,))[2]
                    _status = True
                    _result = value17
               else:
                    _status = False
                    _result = 152
               if _status:
                    _result = staging11
               break
          if (not _status):
               break
          elements = _result
          _result = ListLiteral(elements)
          break
     (yield (_status, _result, _pos,))


def _cont_Atom(_text, _pos):
     backtrack9 = farthest_pos6 = _pos
     farthest_expr6 = 154
     while True:
          while True:
               while True:
                    value18 = '('
                    end18 = (_pos + 1)
                    if (_text[_pos : end18] == value18):
                         _pos = (yield (3, _cont__ignored, end18,))[2]
                         _status = True
                         _result = value18
                    else:
                         _status = False
                         _result = 157
                    if (not _status):
                         break
                    func14 = _ParseFunction(_cont_wrap, (_cont_Expr,), ())
                    (_status, _result, _pos,) = (yield (3, func14, _pos,))
                    break
               if (not _status):
                    break
               staging12 = _result
               value19 = ')'
               end19 = (_pos + 1)
               if (_text[_pos : end19] == value19):
                    _pos = (yield (3, _cont__ignored, end19,))[2]
                    _status = True
                    _result = value19
               else:
                    _status = False
                    _result = 161
               if _status:
                    _result = staging12
               break
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 155
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_LetExpression, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 162
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_Ref, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 163
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_StringLiteral, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 164
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_RegexLiteral, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 165
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_ListLiteral, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 166
          _pos = backtrack9
          (_status, _result, _pos,) = (yield (3, _cont_PythonExpression, _pos,))
          if _status:
               break
          if (farthest_pos6 < _pos):
               farthest_pos6 = _pos
               farthest_expr6 = 167
          _pos = farthest_pos6
          _result = 154
          break
     (yield (_status, _result, _pos,))


def _parse_Atom(text, pos=0):
     return _run(text, pos, _cont_Atom)


Atom = Rule('Atom', _parse_Atom)

class KeywordArg(Node):
     _fields = ('name', 'expr',)
     def __init__(self, name, expr):
          self.name = name
          self.expr = expr

     def __repr__(self):
          return f'KeywordArg(name={self.name!r}, expr={self.expr!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_KeywordArg)



def _cont_KeywordArg(_text, _pos):
     while True:
          while True:
               (_status, _result, _pos,) = (yield (3, _cont_Name, _pos,))
               if (not _status):
                    break
               staging13 = _result
               backtrack10 = farthest_pos7 = _pos
               farthest_expr7 = 172
               while True:
                    value20 = '='
                    end20 = (_pos + 1)
                    if (_text[_pos : end20] == value20):
                         _pos = (yield (3, _cont__ignored, end20,))[2]
                         _status = True
                         _result = value20
                    else:
                         _status = False
                         _result = 173
                    if _status:
                         break
                    value21 = ':'
                    end21 = (_pos + 1)
                    if (_text[_pos : end21] == value21):
                         _pos = (yield (3, _cont__ignored, end21,))[2]
                         _status = True
                         _result = value21
                    else:
                         _status = False
                         _result = 174
                    if _status:
                         break
                    _pos = farthest_pos7
                    _result = 172
                    break
               if _status:
                    _result = staging13
               break
          if (not _status):
               break
          name = _result
          (_status, _result, _pos,) = (yield (3, _cont_Expr, _pos,))
          if (not _status):
               break
          expr = _result
          _result = KeywordArg(name, expr)
          break
     (yield (_status, _result, _pos,))


class ArgList(Node):
     _fields = ('args',)
     def __init__(self, args):
          self.args = args

     def __repr__(self):
          return f'ArgList(args={self.args!r})'

     @staticmethod
     def parse(text, pos=0):
          return _run(text, pos, _cont_ArgList)



def _parse_function_185(_text, _pos):
     backtrack11 = farthest_pos8 = _pos
     farthest_expr8 = 185
     while True:
          (_status, _result, _pos,) = (yield (3, _cont_KeywordArg, _pos,))
          if _status:
               break
          if (farthest_pos8 < _pos):
               farthest_pos8 = _pos
               farthest_expr8 = 186
          _pos = backtrack11
          (_status, _result, _pos,) = (yield (3, _cont_Expr, _pos,))
          if _status:
               break
          if (farthest_pos8 < _pos):
               farthest_pos8 = _pos
               farthest_expr8 = 187
          _pos = farthest_pos8
          _result = 185
          break
     (yield (_status, _result, _pos,))


def _cont_ArgList(_text, _pos):
     while True:
          while True:
               while True:
                    value22 = '('
                    end22 = (_pos + 1)
                    if (_text[_pos : end22] == value22):
                         _pos = (yield (3, _cont__ignored, end22,))[2]
                         _status = True
                         _result = value22
                    else:
                         _status = False
                         _result = 181
                    if (not _status):
                         break
                    staging14 = []
                    checkpoint7 = _pos
                    while True:
                         func15 = _ParseFunction(_cont_wrap, (_parse_function_185,), ())
                         (_status, _result, _pos,) = (yield (3, func15, _pos,))
                         if (not _status):
                              break
                         staging14.append(_result)
                         checkpoint7 = _pos
                         (_status, _result, _pos,) = (yield (3, _cont_Comma, _pos,))
                         if (not _status):
                              break
                         checkpoint7 = _pos
                    _result = staging14
                    _status = True
                    _pos = checkpoint7
                    break
               if (not _status):
                    break
               staging15 = _result
               value23 = ')'
               end23 = (_pos + 1)
               if (_text[_pos : end23] == value23):
                    _pos = (yield (3, _cont__ignored, end23,))[2]
                    _status = True
                    _result = value23
               else:
                    _status = False
                    _result = 189
               if _status:
                    _result = staging15
               break
          if (not _status):
               break
          args = _result
          _result = ArgList(args)
          break
     (yield (_status, _result, _pos,))


def _parse_function_203(_text, _pos):
     backtrack12 = farthest_pos9 = _pos
     farthest_expr9 = 203
     while True:
          value24 = '//'
          end24 = (_pos + 2)
          if (_text[_pos : end24] == value24):
               _pos = (yield (3, _cont__ignored, end24,))[2]
               _status = True
               _result = value24
          else:
               _status = False
               _result = 204
          if _status:
               break
          value25 = '/'
          end25 = (_pos + 1)
          if (_text[_pos : end25] == value25):
               _pos = (yield (3, _cont__ignored, end25,))[2]
               _status = True
               _result = value25
          else:
               _status = False
               _result = 205
          if _status:
               break
          _pos = farthest_pos9
          _result = 203
          break
     (yield (_status, _result, _pos,))


def _parse_function_209(_text, _pos):
     backtrack13 = farthest_pos10 = _pos
     farthest_expr10 = 209
     while True:
          value26 = '<<'
          end26 = (_pos + 2)
          if (_text[_pos : end26] == value26):
               _pos = (yield (3, _cont__ignored, end26,))[2]
               _status = True
               _result = value26
          else:
               _status = False
               _result = 210
          if _status:
               break
          value27 = '>>'
          end27 = (_pos + 2)
          if (_text[_pos : end27] == value27):
               _pos = (yield (3, _cont__ignored, end27,))[2]
               _status = True
               _result = value27
          else:
               _status = False
               _result = 211
          if _status:
               break
          _pos = farthest_pos10
          _result = 209
          break
     (yield (_status, _result, _pos,))


def _parse_function_215(_text, _pos):
     backtrack14 = farthest_pos11 = _pos
     farthest_expr11 = 215
     while True:
          value28 = '<|'
          end28 = (_pos + 2)
          if (_text[_pos : end28] == value28):
               _pos = (yield (3, _cont__ignored, end28,))[2]
               _status = True
               _result = value28
          else:
               _status = False
               _result = 216
          if _status:
               break
          value29 = '|>'
          end29 = (_pos + 2)
          if (_text[_pos : end29] == value29):
               _pos = (yield (3, _cont__ignored, end29,))[2]
               _status = True
               _result = value29
          else:
               _status = False
               _result = 217
          if _status:
               break
          value30 = 'where'
          end30 = (_pos + 5)
          if (_text[_pos : end30] == value30):
               _pos = (yield (3, _cont__ignored, end30,))[2]
               _status = True
               _result = value30
          else:
               _status = False
               _result = 218
          if _status:
               break
          _pos = farthest_pos11
          _result = 215
          break
     (yield (_status, _result, _pos,))


def _parse_function_222(_text, _pos):
     value31 = '|'
     end31 = (_pos + 1)
     if (_text[_pos : end31] == value31):
          _pos = (yield (3, _cont__ignored, end31,))[2]
          _status = True
          _result = value31
     else:
          _status = False
          _result = 222
     (yield (_status, _result, _pos,))


def _cont_Expr(_text, _pos):
     is_first1 = True
     staging16 = None
     while True:
          is_first2 = True
          staging17 = None
          while True:
               is_first3 = True
               staging18 = None
               while True:
                    is_first4 = True
                    staging19 = None
                    while True:
                         (_status, _result, _pos,) = (yield (3, _cont_Atom, _pos,))
                         if _status:
                              staging20 = _result
                              checkpoint8 = _pos
                              while True:
                                   (_status, _result, _pos,) = (yield (3, _cont_ArgList, _pos,))
                                   if _status:
                                        staging20 = Postfix(staging20, _result)
                                        checkpoint8 = _pos
                                   else:
                                        _status = True
                                        _result = staging20
                                        _pos = checkpoint8
                                        break
                         if _status:
                              staging21 = _result
                              checkpoint9 = _pos
                              while True:
                                   backtrack15 = farthest_pos12 = _pos
                                   farthest_expr12 = 196
                                   while True:
                                        value32 = '?'
                                        end32 = (_pos + 1)
                                        if (_text[_pos : end32] == value32):
                                             _pos = (yield (3, _cont__ignored, end32,))[2]
                                             _status = True
                                             _result = value32
                                        else:
                                             _status = False
                                             _result = 197
                                        if _status:
                                             break
                                        value33 = '*'
                                        end33 = (_pos + 1)
                                        if (_text[_pos : end33] == value33):
                                             _pos = (yield (3, _cont__ignored, end33,))[2]
                                             _status = True
                                             _result = value33
                                        else:
                                             _status = False
                                             _result = 198
                                        if _status:
                                             break
                                        value34 = '+'
                                        end34 = (_pos + 1)
                                        if (_text[_pos : end34] == value34):
                                             _pos = (yield (3, _cont__ignored, end34,))[2]
                                             _status = True
                                             _result = value34
                                        else:
                                             _status = False
                                             _result = 199
                                        if _status:
                                             break
                                        _pos = farthest_pos12
                                        _result = 196
                                        break
                                   if _status:
                                        staging21 = Postfix(staging21, _result)
                                        checkpoint9 = _pos
                                   else:
                                        _status = True
                                        _result = staging21
                                        _pos = checkpoint9
                                        break
                         if (not _status):
                              break
                         checkpoint10 = _pos
                         if is_first4:
                              is_first4 = False
                              staging19 = _result
                         else:
                              staging19 = Infix(staging19, operator1, _result)
                         func16 = _ParseFunction(_cont_wrap, (_parse_function_203,), ())
                         (_status, _result, _pos,) = (yield (3, func16, _pos,))
                         if (not _status):
                              break
                         operator1 = _result
                    if (not is_first4):
                         _status = True
                         _result = staging19
                         _pos = checkpoint10
                    if (not _status):
                         break
                    checkpoint11 = _pos
                    if is_first3:
                         is_first3 = False
                         staging18 = _result
                    else:
                         staging18 = Infix(staging18, operator2, _result)
                    func17 = _ParseFunction(_cont_wrap, (_parse_function_209,), ())
                    (_status, _result, _pos,) = (yield (3, func17, _pos,))
                    if (not _status):
                         break
                    operator2 = _result
               if (not is_first3):
                    _status = True
                    _result = staging18
                    _pos = checkpoint11
               if (not _status):
                    break
               checkpoint12 = _pos
               if is_first2:
                    is_first2 = False
                    staging17 = _result
               else:
                    staging17 = Infix(staging17, operator3, _result)
               func18 = _ParseFunction(_cont_wrap, (_parse_function_215,), ())
               (_status, _result, _pos,) = (yield (3, func18, _pos,))
               if (not _status):
                    break
               operator3 = _result
          if (not is_first2):
               _status = True
               _result = staging17
               _pos = checkpoint12
          if (not _status):
               break
          checkpoint13 = _pos
          if is_first1:
               is_first1 = False
               staging16 = _result
          else:
               staging16 = Infix(staging16, operator4, _result)
          arg16 = _wrap_string_literal('|', _parse_function_222)
          func19 = _ParseFunction(_cont_wrap, (arg16,), ())
          (_status, _result, _pos,) = (yield (3, func19, _pos,))
          if (not _status):
               break
          operator4 = _result
     if (not is_first1):
          _status = True
          _result = staging16
          _pos = checkpoint13
     (yield (_status, _result, _pos,))


def _parse_Expr(text, pos=0):
     return _run(text, pos, _cont_Expr)


Expr = Rule('Expr', _parse_Expr)

def _cont_start(_text, _pos):
     while True:
          (_status, _result, _pos,) = (yield (3, _cont__ignored, _pos,))
          if (not _status):
               break
          while True:
               while True:
                    checkpoint14 = _pos
                    (_status, _result, _pos,) = (yield (3, _cont_Newline, _pos,))
                    if _status:
                         continue
                    else:
                         _pos = checkpoint14
                    break
               _status = True
               _result = None
               if (not _status):
                    break
               staging22 = []
               checkpoint15 = _pos
               while True:
                    (_status, _result, _pos,) = (yield (3, _cont_Stmt, _pos,))
                    if (not _status):
                         break
                    staging22.append(_result)
                    checkpoint15 = _pos
                    (_status, _result, _pos,) = (yield (3, _cont_Sep, _pos,))
                    if (not _status):
                         break
                    checkpoint15 = _pos
               _result = staging22
               _status = True
               _pos = checkpoint15
               break
          break
     (yield (_status, _result, _pos,))


def _parse_start(text, pos=0):
     return _run(text, pos, _cont_start)


start = Rule('start', _parse_start)

def _cont__ignored(_text, _pos):
     while True:
          checkpoint16 = _pos
          (_status, _result, _pos,) = (yield (3, _cont_Space, _pos,))
          if _status:
               continue
          else:
               _pos = checkpoint16
          (_status, _result, _pos,) = (yield (3, _cont_Comment, _pos,))
          if _status:
               continue
          else:
               _pos = checkpoint16
          break
     _status = True
     _result = None
     (yield (_status, _result, _pos,))


def _parse__ignored(text, pos=0):
     return _run(text, pos, _cont__ignored)


_ignored = Rule('_ignored', _parse__ignored)

